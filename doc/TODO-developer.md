 - *Undo* functionality!
 - test `centroid` math vector function
 - test `Figure.prototype.centering()` method
 - last grasped figure should be made visibly distict (coloring blur?). Solution: `DOM-mainpulation.prototype.updateElementWithAttributes`. Problem: For focusing, a figure must be moved slightly, no way of intact focusing.
 - z-index: SVG-alakzatok fedési sorrendje
 - Mágneses ragadás
 - Ütközés szaggatottsága, ,,pattanás'' (távolságtartás gyors berántásnál)-hiba megoldása
 - A tervrajz mentése -- ha a javScript biztonság okokból nem enged fájlba menteni, akkor a mögöttes PHP-szerveren regisztrálható felhasználóprofil adatbézisába menthet. Ez a sok felhajtás a korai fejlesztési szakaszban kiváltható azzal, ha a ,,mentés'' egyszerűen a fő adatszerkezet JSON.stringify-formátumban kiíratható, onnan akkor a user egérrel lemásolhatja, és sajétkezűleg fájlba mentheti. Innen meg JSON.parse-szal bárikor visszaolvasható.
 - Hanghatás ütközésnél: a hangfájlot saját mikorofonfelvétellel is elkészíthatjük (pl taps, fémkanál leejtése), így nincs vendorporbléma (szerzőijog- vagy köszönet/hivatkozás).
 - A felhasználói felület parancsai (kiválasztható beszúrandó alakzattípus, regiszeterk, akuumulátorok bufferek, reakciók a helyzetnek és a bényomott parancsgomboknak függvényében) tulajdonképp nem más, mint állapotgép! Ez jó modularizálhatósáágra adlehetőséget. Szélsőségesen jó esetben akár saját domainspecifikus nyelv is tervezhető, és az állapotgép nyelvtana teljesen reifikálható.
 - felhasználói doksi, jó fejlesztői doksi, Utóbbi részeként tesztdoksi.
 - A két projekt (`llosely-coupled-figure-editor` és `floor-plan-designer`) a régi tudás minnél teljesebb haasznosítása, ne vesszék el a régi projektből semmi tudás. Különösen ügyelni a két `TODO` file összefésülésére, ne zavarjon meg, hogy e két külön tartalmú  file ugyanazon a néven létezik.
 - `WidgetVerticalPillar` osztály bevezetése nagyon érik már, akár ,,globális'' szingelton osztály lesz, akár alazatonként, azokhoz kötősve egyéni példányonkénti
 - Járjunk utána, milyen rokon JavaScript alkalmazások, könytárak léteznek alakzatszerkesztés, ütközésvizsgálat, widgetek terén
 - Jobb egérgomb kattintásának kihasználása nagyon modern, felhasználóbarát, gazdag, kifejező és tömör használati módot tenne lehetővé. Gondolom `preventDefault` kell hozzá. oncontenxtmenu: see [Is right click a JavaScript event?](https://stackoverflow.com/questions/2405771/is-right-click-a-javascript-event).
    - Egyébként a jobbegérrel addig is kell kezdeni valamit, amíg nem használjuk ki, mert megzavarja a kattintsok ,,állapotgépét''.
 - Az alakzatok ,,típusbabkjába'' a felhasználó is menthesse be az általa épp megszerkesztett, ezáltal újfajta alakzatokat.
 - Vezessünk be magasszintű eseményeket és eseménykezelést! A JavaScript natív eseménykezelése mintájára, de attól függetlenül! Amelyek pl. ütközés- és közelség-eseményeket vizsgálnak a geometriai figurákon, vagy esetleg még magasabb szinten is majd a lakáselemeken!
 - Ütközés esetén csak csússzék meg az egérkurzoron, de ne jöjjön le a vonszolásról! Nagyon zavaró, ráadásul a nem teljes ütközésellenőrzés miatt becsapható alakzatütközések is sokkal nehezebben kutathatók így.
 - Copyright for `sonar.ogg` alertsound, or produce own sound.
 - HypotheticlWorld, vagy FutureWold, vagy Collision nevű külön osztály az ütközéskereső interációra! Itt a hypotheticus alak olyan dolog, amit pont érdemes egy osztály instanciaváltozójaként számontartani.

 - Az OriginFigure-t nem kell a ma App modulnak nevezett modulbnan nyilvántartani, az inkábbkb. a StateMachine hatásköre. A Statemachine amúgy lehet, hogy valamikor átveszi a mai App helyét.
 - A mai WidgetFactory-ból az eseménykezelős rész nem oda való, kerüljön külön WidgetEventPillar modulba, ami tersészetesen szintén a widget-pillar könyvtárban lenne. A WidgetEventPillar-nak ne kelljen ismernie sem a ma App-nak nevezett modult, se a StateMachine-t: lazy coulpling. Majdhogynem azt mondanám, hogy egyszerűen return-öljön vissza tömb- vagy objektumcsomagokat, de pesze ez nem szó szerint értendő, mert egy ilyen eseményfeldolgozó mindenképp kontrollinformációt is tartalmaz (végső soron egérkattintások hívják meg), így természetesen callback-en keresztül révényesül. Ez a callback viszont legyen teljesen megötésmentes, ne kötődjék konrét modullmetódushoz, max esethleg interfészhez, vagy sima mezei callbackhez.
 - Bár a WidgetEventPillar nagymértékben irányítja az egész alkalmazás eseményciklusát, mégsem kell feltétlen a control könyvtárba áttenni. Ugyanis ő csak az SVG root-DOM-elemre rakott eseményeket figyeli.  Az alkalmazás végső eseményciklusának ő csak az egyik bekötöttje lesz, vele egyenrangúan lesz békötve a GUI egyég gomjainak, válastós listáinak figyelése is.
 - Valószinűleg lesz egy PhysicalEvent jellegű modul is -talán épp a physics mappában, ami az ütközésekből gáyrt valamiféle magasszintű, virtuális eseményt. A jelenlegi WidgetEventPillar-ban az ütközés keresése túl szorosan van hozzákötve. Az lenne a jó, ha a WidgeteventPillarnak nem mkéne ütközéekkel töröödnie, és bár az ütközésesemény ugyan valóban önálló nevű 'collision' esemény lenne a 'mousedown' és esgéyb események mellett vagy flett, de nem a WidgetEventPillar képezné, hanem  a CollisionEventDecoratort valamiféle dekorátorként vagy fasszádként lehetne hozzácsatlakoztatható a WidgentEventPillarhoz.
 - App should load in the initial sample figures (not the injectorMain should do that! Maybe the StateMachine should do that (in its init part) instead of App
 - The module now called as `App` should be renamed, no more being the top-level module (after injectorMain).
 - A lot of functions in the `injectorMain` should move to a new Module, being called App, the formar App module shoud be ranemed,

 - Gombkattitással és billentyűleütéssel egyaránt lehessen kezelni a kezelőfelületet, alakzatokat
 - legyen TAB gomb, ill a TAB-bilenyűleütés is arra a funkcióra, hogy a fókusz váltható legyen az összes alakzaton végig. Legyen persze alakzathozzáadó és törlő gomb ill billentyű is.
 - Legyen alakzatfókusz is és ürespozíciófókusz is. A kettő kizárja egymást: ha alakzatra kattintok, alakzatfókusz és az az alakzat fókuszba kerül. Ha üres helyre kattintok, a fókuszalakzat elveszti fókuszát, és üreshelypozíciófókusz képződik. Előbbi törlésre, utóbbi beszúrásra reagál. Az ürespozíció (WEPOs)-fókusz esetleg meg is jeleníthető (kis pötty, kis kereszt?) bár nem szükségszerű.
 - Az Insert és a Delete nem mód, hanem funkció. Két mód elég: a jelenelg Obsolete-nek nevezett Kompakt mód, és a Normál mód. A Normál mód legyen az alapértelmezés.
 - Kurzornyilakkal is lehessen mozgatni (tologatni) az alakzatokat. Alternatív megoldás: csúszkákkal. A csúszkák forgatáshoz, és tükrözéshez is használhatók
 - Az ürespozíció-fókusznak és az alakzatfókusznak nem kell felétlenül egymást kizáróank lennie. Lehet az is, hogy háromféle fókusz lehet a bufferben: alakzatfókusz, pozíciófókusz és orientációfókusz. Az alakzat- és a pozíciófókusz szerepe az lenne, ami eddig, plusz még a pozíciófókusz felhasználható lenne még forgatás középpontjának megadsára is. Az orientációfókusz meg tükrözés tengelyét adná meg (a pozíciófókusszal együtt)

 - Az alakzatoknak referenciapontjuk mellett referenciaszögök is legyen. Ez lehet automatikus: a konstruktor megadhat default 0 referenciaszöget. A lényeg, hogy a forgatás kövesse. Átgondolandó askálázások hatása, de szerintem nem hatnak rá. Épp fordítva: a scaleX és scaleY a referenciaszög szerint számít mostantól, nem az abszolút vízszintes szerint.
 - Legyenek buktatások: az alakzat legyen képes rábukni a taplpára, illetve a következő/előző oldalára vízszntesbe.

 - Az Állapotgépet lehetne több részre vágni. Egyelőre megtartanánk az egységes közös Állpotot (State). A State osztálynak sajt metódusai nem lennének (csak getterek és szetterek), vagy még azok sem, szóval csak példányváltozói lennének. A közöst State-t sok Machine használná(var machine1 = new Machine1(state). Több osztály is lenne a Machine-k között. Az  egyes Machine osztályok a bemeenet és a kimenet alapján különölnének el. Bemeneten értjük a transition függvény szignatúrájának a bemeneti dolgokra vonatkozó részét, kimeneten meg azt, hogy a Machine milyen akciókat, tevőleges dolgokat hajt végre (rajzolások pl.), vagyis hogy milyen modulokat kell importálnia, használnia, hogy feladatát végezhesse. A ,,közös'' State kiemelésével a Statemachine-ből, és a ,,megmaradt'' Statemachine szétvgágása külön StateMachine-kre: így a felhasználó felület még tisztábban elválik a matematikai motortól, így még könnyebb lesz tetszőlegesen testre szabni a kívánt felhasználóbarát kezelőfelületet. A mostani betűparancsok elvileg továbbélhetnek majd olyan formában, hogy egy felhasználó által programozható szöveges szkriptnyelv részeivé válhatnak. Persze ez a jelen feladat szempontjából nem fontos, ezt csak a TODO listába írom be.
 - Legyen belső API, esetleg majd REST API is. ,,API frst'' szemlélet?

 - Legyen magasz ,szintű, ütközés típusú eemény! Ahogy az seseményfeldobó programrész képes már geometriai (és nem SVG-koordinátás) szintű információkat feldobni, ugyanúgy legyen ezen a téren is egy kis fogalmi emelés: ne csak natív eseményeket dobjon fel! Az e event objektum helyett legyen valami Either Event MyHighlevelEvent! Ez még ne akarja az ütközést tényelges lekezelni, hanem infókat tartalmazzon, amit aztán bármilyen ütközésszabályzat szerint fel lehessen dolgozni. Amúgy ez a saját magaszintű ütközésesemény elvégezhet ütözésinterpolációs számításokat is, az nincs megtiltva, használhat és mozgathat virtuális próbafigurát. Az van csak megtiltva, hogy a tényleges figurán ö maga akciót hajtson végre, az eredeti figurát tevőleges visszarántsa valami kiszámolt pozícióba. Ezt ne tegye, csak infókat adjon!

 - Teszteleni normál módnál és kompakt módnál is: ha a `sampleBank` által beszúrt egyik alakzatot elcsavarom, aztán elkezdek stamp-elni úgy, hogy épp azt az alakzatot választom ki pecsétnek, akkor a torzított  pecsétet teszi ki, vagy az eredetit?
    - általában is ellenőrozni kell, hogy pecsételéskor, mág általánosabban létrehozáskor történik-e klónozás ott, ahol kell, és klónozásmentes-e ott, ahol fölösleges lenne klónozni.
 - Az ütközésnél a rugalmas fogómegcsúszás visszahajlása is, és az átbuktatás is végre rendben működik, de objktumot egy másik objektum éle mentén csusztatni, reszelni nem lehet. Ezt is valósítsuk meg!

 - A körüljárásdetektálási hiba javítása (amikor sem +360 fok sem -360 fok nem jön ki a külső szögek összegére - átnyúló konkáv szögeknél jelenik meg ilyesmi).

 - `flat` and `flatMap` are experimental, do not use them, define them expilcitly!
 - Define a  `mbMinBy2WayCmp` and `minsBy3WayCmp` function, and redefine `nearestFiguresHence` and `nearestVerticesHence` and `maybeNearestFigureHence` and `maybeNearestVerticeHence` (and possibly others as well) by them (lift out the common pattern).
 - put to a separate class? Figure is already a too large class. `addVertex`, `deleteVertex`, `moveVertex` by proximity heurietics should come directly into `Figure`, or should we use a spearate `FigureEditor` class?
 - Amikor az alakzatszerkesztővel nagyon hegyes, sziklaszerű kitüremkedésű alakzatot állítok elő, néha az ilyen sziklaszerű kitüremkedés áthatolható marad az ütközésérzékelés számára. Ez persze hiba. lehet, hogy a háttérben átmetsző vonalmetszésű, invalid poligon áll, amelyen ez nem látszik szemre.
 - `injectorMain`, `Router`, `FigureEditorController`, `GeomTransformationController`: dönteni kell abban, hogy e kontrollerek a `NormalModeController`-rel és a `CompactModeConroller`-rel közös nagy `State` állapotosztályt használják-e, vagy saját állapotterük legyen, akár úgy, hogy közvetlen az adott kontroller attributumaként, akár minden egyes kotrollerhez külön-külön egy-egy a kotrollerhez tartozó State* osztályként.
     - Valószínűleg inkább mégis érdemes megtartani a `NormalModeController`-rel és a `CompactModeConroller`-rel közös nagy `State` állapotosztályt a `FigureEditorController` és a `GeomTransformationController` számára is. Ugyanis egyáltalán nem biztos, hogy ezeknél továbbra is a ,,legközelebbi alakzat heurusztukéjéra'' fogunk támaszkodni. A legközelebbi pont és él (adott lakazaton belül) heurisztikája megmaradhat, de magát a szekesztendő vagy transzformálandó alakzatot a fókusz fogja megadni, nem közelségi heurisztika. Ebben tehát az a `FigureEditorController` és a `GeomTransformationController` használni fogja az alakzatfókuszt, sőt, lehet, hogy maguk e kontrollerek maguk is beleolvadnak a `NormalModeController`-be. Ennek fő oka, hogy előfordulhat, hogy oly alakzat csúcsát akarom elmozgatni, amely alakzat épp abban a csúcsban közös csúcsot alkot egy másik alakzat ccsúcsával. Ekkor a két csúcsa közelségi heurisztika számára megkülönböztethetetlen, de az alakzatfókusz tökéletes megoldást adna. Ezért a `FigureEditorController`-nak mindenképp át kéne venni a fókusz használatát. A `GeomTransformationController` esetleg használhatná a közleségi heurisztikát, de talán az is jobb ha fókuszalapú.
 - A közelségi heurisztika kérdéses, de elfogadható forgatásnál, esetleg skálázásnál (itt kimagyarázható feature lehet, hogy az alakzatot nemcsak belső pontjánál fogva ragadhatom meg), de tükrözésnél már inkább zavaró a közelségi heurisztika. Elég, ha a BELÉkattintás (currentWidget) vizsgálata lapján dolgozik.
 - Megcsináltam az egérrel való vonszolós, interaktív forgatást, és hamarosan kész lesz a többi transzformáció itisztán egeres-interaktív változata is. Egyylre még nem végez ütközésvizsgálatot, tehát egy alakzatot bele lehet forgatni egy másik alakzattal érvénytelen helyzetbe is. Ennek során kiderült, hogy a program ilyenkor hibaüzenett ad, tehát nem talál rá valamiféle erre előkészített kivételere. Bár nyilván hamar meg lesz írva a transzformációk ütközésvizsgálata, de a probléma túlmutat ezen. Alacsony szinten is legyen jól lekezelve az érvénytelen helyzet. A hibaüzenet:
        Uncaught TypeError: pMInf1 is not iterable
            at pMInfCompare (Infinity.js:64)
            at reducer (Infinity.js:164)
            at boardReduce (Board.js:5)
            at boardMinSelectSet (Infinity.js:175)
            at fallFigureOnBoard_allMins (FiguresBoard.js:5)
            at mbVectorTransformer (collision-as-vector-transformation.js:5)
            at infinitezimalDisplacement (collision-as-vector-transformation.js:1)
            at NormalModeController.mouseMove (NormalModeController.js:33)
            at Router.dispatch (Router.js:28)
            at mergelessSubscribe (WidgetEventPillar.js:18)

 - Az ütközés invalidus helyzetei más érdekeségre is rávilágítanak. Van két nagyon pici négyzet, az egyik pont a nagyon konkávalakzatnál. Ez érzékeltlen az ütközésre beforgatáskor. Miért? Akr direkt volt így, akr nemszándékolt melékhatása valaminek, érdemes lenne utánanézni. Ez az átjárhatóság ugyanis pont jól jönne nyilászáróknál.
 - Az Alakzatszerkesztő (Figure Editor) rendelkezzék területtartási kapcsolóval, opcióval is!
 - Amikor az alaprajzot natív  formátumban mentjük, tervezzük meg ezt a natív formátumot minél nyitttabra! Lehessen az alkalmazás nélkül is, sima szövegszerkesztőben is alaprajzokat szerekszteni! Lehetőleg legyen olyan ebben a nyitottsgban, mint a LaTeX!
 - Ha már natív mentés: legyen Redo (az alakalmazásban), a metést pedig kísérje valamiféle saját verziókövetés!
 . az  `ird.currentWEPos` érzékelését törzítja, ha pl. egérvonszolás közben megváltozik az oldal layoutja (pl. mert a debuggoló konzolüzenet hol két sorba, hol egy sorba fér ki). Ez valószínűleg lacsonyszintű jelenség, és a `.svgPoint.matrixTransform(this.svgRootElement.getScreenCTM().inverse())` szintjéig nyúlik vissza.
 - Tudjuk, hogy már lehet egérrel pontot hozzáadni, törölni, vonszolni. Továbbá lehet egérrel alakzatot forgatni. Mindezt kényelmesen intuitívan, tehát vonszolással,
Az ütközésvizsgálat közben értelemszerűen működik (vagyis nem lehet alakzatot tilos helyzetbe beforgatni). Ugyanakkor, ez az ütközésvizsgálat az alakzatszerkesztés (csúcspontok hozzáadása, mozgatása) esetében nem működik! Pl. csúcsot mozgatva bele lehet trappolni egy másik alakzaba.
 - Ami még nembiztonságos ily szempontból, az a stamp (pecsételés): új alakzat beszúrása minta alapján előzetesen kijelölt spaceFocus-ba.
 - Az alakzatszerkesztőre visszatérve, ennek ütközásvizsgálati hiányosságától függetlenül is, a közelségi heurisztika kissé katasztrofális az alakzatszerkesztőben. Nem a csúcsok, élek közelségi megsejtésével van a baj, hanem a legközelebbi alakzat közelséi heurisztikájával. Nagyon csúnyá össze lehet kuszálni az  alakzatszekesztés vele (pl. egy mozgatott csúcs esetén, ha túl közel megyünk vele egy szomszéd alakzathoz, akkor a szekesztés váratlanul átugrik a szomszéd alakzatra).
 - És ettől is függetlenül, baj, hogy az alakzatszekesztő megengedni, hogy kereszteződő élű, kifordult alakzatok jöjjenek létre.
 - ,,Abszolút'' magyarítása: önmagábanálló?
 - Most, hogy több vászon van, és egymás közt át lehet húzogatni az alakzatokat, látszik, hogy valójában a vásznak még mindig közös board-on osztoznak, ezértpl. ha egy sűrűn benépesített vászonról egy üres vászonra húzok átt egyetlen alakzatot, az az alakzat az új vásznon belül furcsán, botladozva lesz csak mozgatható (szellemütközés), ugyanis pont úgy fog viselkedni, mintha ütköznék azokkal az alakzatokkal, amelyek a másik vásznon vannak, de ugyanazon a koordinátákon (ghost collisions).
 - make two audios. One for collision, another for jumping over to another canvas. Maybe a third one for teleporting over a figure or a group of figures.
 - Az alakzatszerkesztő ütközésvizsgálata mellett fontos még, hogy ne tudjon invalidus (pl áthurkoló) alakzato létrehozni. a poligonvalidusság szabályai:
    - a szakaszok nem metszhetik egymást
    - érintkezni csak kölcsönösen végpontjaikban érintkezhetnek
    - csúcsból csak két szakasz indulhat ki.
 - A protabilitást, hordozhatóságot mindenképp vizsgálni kell, legfontosabb a dokumentáltan is experimental vonások kiváltása. Két ilye nbiztos van: `Array::flatMap` és `DOM-Node::after`.
 - Ha az alakzattulajdonságok űrlapján területtartás kérek, és nagyon hosszúra nyújtatok egy téglalapot, akkor szélessége epszilon alá fog keskenyedni, ilyekor az ütközésérzékelő a holtjáték-ráhagyás miatt nem fogja érzékelni az ürközést! Lesz egy szomzédokba beledöfő hosszú vonal. Ezt vissza lehet zsugorítani, de csak nem-ütköző méretre. a 90000-es hosszúságot vissza lehet venni 80000-re (hisz az sem ütközik), 300-ra már nem lehet visszavenni (hisz az már nem megy epszilon alá, így már ütküzik). Kicsi, valóban nem ütköző értékre, pl. 2-re vissza lehet venni.
 - Eldönteni, hogy a jelenleg a `textual-widgets` mappában a ...`UI.js` fájlokat ne nevezzük át `widgets` mappára és ...`Widget.js` névre.
 - Status bar (Statusleiste): a jelenleg msgConsole nevű tájékokatató kis konzolüzenetes rész kerüljön legalul egy teljesszéles sorba!
 - Az `areaInvarianceRadio` constansnak (DOM-elem) nagyon rossz a neve. Valójában jelölőnégyzet, nem rádiógomb.
 - Az lenne a jó, hogy amikor a területtartást mint opciót bejelölöm, automatikusan hide-olásra, vagy méginkább, inaktiválásra kerülnének azok a gombok, úrlapelemek, linek, amelyekhez területmódosító műveletek tartoznak.
 - Az areanvariance nem az alakzattulajdonságok közé tartozik! Ne is az az UI (device) kezelje le! hanem inkább valamiféle ConfigUI! A terülelttartás ugyanis az alakalmazás teljes működését áthatja! Ezért valóban inkább valamiféle confignk számít. Hasonló még az epszilon, az is ide kerrülhetne! (jelenleg szerencsétlen módon az svgLowlevel vagy a widgetFactory része). Továbbá még talán az Attila által mutatott zoomolás stb. lehet még ilyen, vagyis egy config dologhoz tartozó dolog. Mindenképp a confighoz tartozik viszont a bennfoglalásos transzforációöröklődés flagkészlete (vagyis, hogy szoba mozgatásakor, forgatásakor, nagyításakor, tükrözésekor a bennelévő bútorok is mozogjanak, forduljanak, átméreteződjenek,tükröződjenek-e). Ezt minden egyes transzformációra külön lehetne szabályozni.
 - Miért tartunk fenn külön controller és külön UI (device) modulpárokat? Egy megoldás a jelenleg `ConfigDriver` fájlban látszik: a driver bemeneti és kimeneti alacsonszintű kommunkiációs egyaránt támogagat. Tehát checkbox fizikai becsekkolását ugyanúgy, mint a checkválástkor felszabaduló eseményre való rácsatlakoztathatóságot. A kimenő kommunikáció kicsit hasonlít az MVC view ill helper részére, de nem azonos azzal. A driver ugyanis inkább  tényleg csak maguknak az DOM-elemeknek a puszta elérhetőségét nyújtja, mint ahogy az eseményeket is csak beköti. Tehát alacsonyszintű, de kétirányú.
 - Device vs driver megkülönöböztetés: a korábban UI, most Device  néven nevezett modulok nevezéktana ezúttal Driver lesz. A hozzájuk tarotzó device ugyanis inkább maga az a DOM-csomópont, elem, eseményforrás, illetve vászon, amit ellát. Theát pl. lehet, hogy az SvgLowlevel neve device lesz, bár ez tallán inkább maga a vászon, illetve maguk az egyes <svg> DOM-elemek.
 -Drivernek tekinthető az `msgConsole` is, új neve `StatusBarDriver` lehetne, esetleg méginkább `StatusBarODriver`, mert ő csak output device driver, hiszen ő maga nem vált ki eseményeket (reagál ugyan eeményekre, de csak magas szintről, kontrollerek meghívásain keresztül). Akkor lenne `StatusBarIODriver`, ha pl. a statusbar kikapcsolaható lenne saját csekboxról stb., vagyis ha sajátjogon lennének eseményei. Mindenesetre épp ezért (könnyen válhat egy idriver vagy odriver iodriverré) ne az osztályok, csak a belőlük képzett objektumpéldányok változóneve mutassa, hogy I-, O- vagy IO-driverről van-e szó!
 - Amúgy az SvgLowLevel, vagy talán méginkább a WidgetEventPillar lehet hogy szintén driver. A `Controller.prototype.maybeJumpingWidget = function (targetCanvas)` metódusnak ha talán nem is az egésze, de a svg-pologonelemeket a szülő canvas elemmel való összetartozását vizsgáló összehasonlító részének szintén valamiféle svg, poligon vagy vászon jellegű driverhez kellene tartoznia. A `widgetFactories` tömb, amit rendre átadunk az egyes controllereknek, szintén lehet hogy szintén drivertermészetű.
 - A `FigurePropertyEditorController` metódusait érdemes nézegetni. A controller függ a documet-től, és hatalmas DOM-szerkesztések vannak benne közvetlenül. Mindkettő hiba: ezeket ki kell delegálni egy külön  erre létrehozott drivernek.
 - A FigurePropertyEditor mezőiben ahol számot kell beadni, validálni kellene számformátumra, mert ha érvénytelen adatot kap, akkor nagyon csúnyán eldurran, alacsonszintű NaN hibák, sőt az alakzat is eltűnik!
 - A rádiógombok, checkboxok csak akkor reagálnak, ha egyenesen beléjük kattintok, nem elég a hozzájuk tarotzó címkére kattintani. Használjuk ki a HTML <label for="..."> szolgáltatását!
 - A FigurePropertyEditor legyen kétirányú: vagyis amikor egy alakzaton az egérrel mértani transzformációkat végzünk, az értékeke folyamatos változása élőben kvethető legyen a FigurePropertyEditorban is!
 - A FigurePropertyEditor mutassa az alakzat aktuális referenciaszögét is!
 - A FigurePropertyEditor-ban lehessen a szoba nevét is átírni!
 - A FigurePropertyEditor jobb hiján felhasználható átmenetileg arra, hogy falréseket hozzunk létre: közvetlen szereszhetőv étehetjük benne az SVG elem stroke-dasharray attribútumát. Ez nagyon alacsonszintű, de azonnal bizton működő megoldás, a felhasználóbarátságot adandóó matematikai rutinok meg utólag is megírhatóak ,,föléje''.
 - A space fókusz (poziciófókusz),  ami kijelöli a következő beszúrható alakzat helyét: Attila kérése volt, hogy vizuálisan is látszódjék. Ez lehetséges lenne, ez e célt szolgáló alakzato nem teszzük be a board-ba, így könnyűvé válik elkülönítése a többi alakzattól. Esetleg bekerülhet a boardba, de külön domain fajtája különíti el őt a többitől.
 - A jobb oldali vászon legyen gombnyomásra benépesíthatő. Hiszen ha onnan rakodok át alakokat a baloldali vászonra, akkor a jobboldalinak bármikor gombnyomásra megújíthatóan kell lennie (vagy pedig másolós vonszolás kell).

 - Expand/contract, illetve push/pull ikonként is meglegyen (élre, nem alakzatra, és tán nem is a geom transzformációk, hanem a csúcs add del move közé), tehát ne csak az alakzatttulajdonság-szerkesztő inputmezeiben való átirogatással lehessen pl. egy L-szoba vagy egy trapéz falait kényelmesen tologatni.
     - Tehát: van geom transz, van alakztatszerkesztő, amin belül van csúcsszerkesztő (add del mov) és élszerkesztő (expand/contract és push/pull).
     - tulajdonkéép az expandcontract versus pushpull oppozíció pontosan megfelel a vízszintes versus függőleges opciónak. De megegyeztük, hogy a vízszintes vs függőeges elletnétpárt opcióként nem veztjük be, hanem szétosztjuk a műveletek között. Persze ez mindig vitatható.
 - A domainObject nevének kiíratási szabálya: a (potenciálisan konkáv) poligon legnagyobb területű konvex részpoligonjának súlypontjához kerüljön a névfelirat közepe. Ez matematika. Egyébként  lgnagyobb terület nem jó (magas elvékonyodó is lehet). Legrosszabb  esetben kontruáláskor végiglépdelünk a poligon könyezetében, próbálgatva.)
 - Mixin vagy trait bevezetése az implementációban. Pl. a Figure is, aWidget is már túl sok felelősséget vállal, túl heterogén. Ahol immár azonnali döntésre is szükség van: a State osztály interpretációt vállaló része (State.prototype.interpret)
 - Ha egy alakzatot átugrasztok a másik vászonra (és vissza), az új (és az új-régi) vásznon automatikusan legfölsőnek (z-ccord) fog számítani. Ez igaz a címekre is!
 - Forgatáskor a forgó szoba felirata értelemszerűen igazodjék a szoba helyzetéhez (pl. L alakú szoba forgatásakor ugorjék át a megfelelő öbölbe). Ugyanez teljesüljön a többi transzformációra is, sőt az alakzat alakszerkesztésére is (élek feszítése-sűrítése, húzása-tolása, csúcspont hozzáadása, elvétele, mozgatása). Ebből a csúcsszerkesztésekhez való autoigazodás megvan,de az élszerkesztésekhez majd meg kell írni.
 - Él tolásakor előfordulhat, hogy a rövvidebbik élet rátolom a vele párhuzamos hosszabbik élre (vagy fordítva). Ilyenkor a közelségi heurisztika miatt valószínűleg nem lehet széstesdni őket, mert a közelségi heurisztika csak akkor képes megkülönböztetni őket, ha átállok a hosszabb él kikógó részére.  Ha a két él pont egyenlő nagyságú, akkor még ez a kiskapu sincs.
 - Az alakzattulajdonságszereksztőben lehessen a címet és a terüetet átírni! A cím átirása világos, a teület átírásánál meg az automatikus skálázás hasson!
 - Lehetőleg a címet lehessen közvetlenül is átgépelni, de ezt nem kell erőltetni.
