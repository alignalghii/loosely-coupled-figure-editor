 - *Undo* functionality!
 - test `centroid` math vector function
 - test `Figure.prototype.centering()` method
 - last grasped figure should be made visibly distict (coloring blur?). Solution: `DOM-mainpulation.prototype.updateElementWithAttributes`. Problem: For focusing, a figure must be moved slightly, no way of intact focusing.
 - z-index: SVG-alakzatok fedési sorrendje
 - Mágneses ragadás
 - Ütközés szaggatottsága, ,,pattanás'' (távolságtartás gyors berántásnál)-hiba megoldása
 - A tervrajz mentése -- ha a javScript biztonság okokból nem enged fájlba menteni, akkor a mögöttes PHP-szerveren regisztrálható felhasználóprofil adatbézisába menthet. Ez a sok felhajtás a korai fejlesztési szakaszban kiváltható azzal, ha a ,,mentés'' egyszerűen a fő adatszerkezet JSON.stringify-formátumban kiíratható, onnan akkor a user egérrel lemásolhatja, és sajétkezűleg fájlba mentheti. Innen meg JSON.parse-szal bárikor visszaolvasható.
 - Hanghatás ütközésnél: a hangfájlot saját mikorofonfelvétellel is elkészíthatjük (pl taps, fémkanál leejtése), így nincs vendorporbléma (szerzőijog- vagy köszönet/hivatkozás).
 - A felhasználói felület parancsai (kiválasztható beszúrandó alakzattípus, regiszeterk, akuumulátorok bufferek, reakciók a helyzetnek és a bényomott parancsgomboknak függvényében) tulajdonképp nem más, mint állapotgép! Ez jó modularizálhatósáágra adlehetőséget. Szélsőségesen jó esetben akár saját domainspecifikus nyelv is tervezhető, és az állapotgép nyelvtana teljesen reifikálható.
 - felhasználói doksi, jó fejlesztői doksi, Utóbbi részeként tesztdoksi.
 - A két projekt (`llosely-coupled-figure-editor` és `floor-plan-designer`) a régi tudás minnél teljesebb haasznosítása, ne vesszék el a régi projektből semmi tudás. Különösen ügyelni a két `TODO` file összefésülésére, ne zavarjon meg, hogy e két külön tartalmú  file ugyanazon a néven létezik.
 - `WidgetVerticalPillar` osztály bevezetése nagyon érik már, akár ,,globális'' szingelton osztály lesz, akár alazatonként, azokhoz kötősve egyéni példányonkénti
 - Járjunk utána, milyen rokon JavaScript alkalmazások, könytárak léteznek alakzatszerkesztés, ütközésvizsgálat, widgetek terén
 - Jobb egérgomb kattintásának kihasználása nagyon modern, felhasználóbarát, gazdag, kifejező és tömör használati módot tenne lehetővé. Gondolom `preventDefault` kell hozzá. oncontenxtmenu: see [Is right click a JavaScript event?](https://stackoverflow.com/questions/2405771/is-right-click-a-javascript-event).
    - Egyébként a jobbegérrel addig is kell kezdeni valamit, amíg nem használjuk ki, mert megzavarja a kattintsok ,,állapotgépét''.
 - Az alakzatok ,,típusbabkjába'' a felhasználó is menthesse be az általa épp megszerkesztett, ezáltal újfajta alakzatokat.
 - Vezessünk be magasszintű eseményeket és eseménykezelést! A JavaScript natív eseménykezelése mintájára, de attól függetlenül! Amelyek pl. ütközés- és közelség-eseményeket vizsgálnak a geometriai figurákon, vagy esetleg még magasabb szinten is majd a lakáselemeken!
 - Ütközés esetén csak csússzék meg az egérkurzoron, de ne jöjjön le a vonszolásról! Nagyon zavaró, ráadásul a nem teljes ütközésellenőrzés miatt becsapható alakzatütközések is sokkal nehezebben kutathatók így.
 - Copyright for `sonar.ogg` alertsound, or produce own sound.
 - HypotheticlWorld, vagy FutureWold, vagy Collision nevű külön osztály az ütközéskereső interációra! Itt a hypotheticus alak olyan dolog, amit pont érdemes egy osztály instanciaváltozójaként számontartani.

 - Az OriginFigure-t nem kell a ma App modulnak nevezett modulbnan nyilvántartani, az inkábbkb. a StateMachine hatásköre. A Statemachine amúgy lehet, hogy valamikor átveszi a mai App helyét.
 - A mai WidgetFactory-ból az eseménykezelős rész nem oda való, kerüljön külön WidgetEventPillar modulba, ami tersészetesen szintén a widget-pillar könyvtárban lenne. A WidgetEventPillar-nak ne kelljen ismernie sem a ma App-nak nevezett modult, se a StateMachine-t: lazy coulpling. Majdhogynem azt mondanám, hogy egyszerűen return-öljön vissza tömb- vagy objektumcsomagokat, de pesze ez nem szó szerint értendő, mert egy ilyen eseményfeldolgozó mindenképp kontrollinformációt is tartalmaz (végső soron egérkattintások hívják meg), így természetesen callback-en keresztül révényesül. Ez a callback viszont legyen teljesen megötésmentes, ne kötődjék konrét modullmetódushoz, max esethleg interfészhez, vagy sima mezei callbackhez.
 - Bár a WidgetEventPillar nagymértékben irányítja az egész alkalmazás eseményciklusát, mégsem kell feltétlen a control könyvtárba áttenni. Ugyanis ő csak az SVG root-DOM-elemre rakott eseményeket figyeli.  Az alkalmazás végső eseményciklusának ő csak az egyik bekötöttje lesz, vele egyenrangúan lesz békötve a GUI egyég gomjainak, válastós listáinak figyelése is.
 - Valószinűleg lesz egy PhysicalEvent jellegű modul is -talán épp a physics mappában, ami az ütközésekből gáyrt valamiféle magasszintű, virtuális eseményt. A jelenlegi WidgetEventPillar-ban az ütközés keresése túl szorosan van hozzákötve. Az lenne a jó, ha a WidgeteventPillarnak nem mkéne ütközéekkel töröödnie, és bár az ütközésesemény ugyan valóban önálló nevű 'collision' esemény lenne a 'mousedown' és esgéyb események mellett vagy flett, de nem a WidgetEventPillar képezné, hanem  a CollisionEventDecoratort valamiféle dekorátorként vagy fasszádként lehetne hozzácsatlakoztatható a WidgentEventPillarhoz.
 - App should load in the initial sample figures (not the injectorMain should do that! Maybe the StateMachine should do that (in its init part) instead of App
 - The module now called as `App` should be renamed, no more being the top-level module (after injectorMain).
 - A lot of functions in the `injectorMain` should move to a new Module, being called App, the formar App module shoud be ranemed,

 - Gombkattitással és billentyűleütéssel egyaránt lehessen kezelni a kezelőfelületet, alakzatokat
 - legyen TAB gomb, ill a TAB-bilenyűleütés is arra a funkcióra, hogy a fókusz váltható legyen az összes alakzaton végig. Legyen persze alakzathozzáadó és törlő gomb ill billentyű is.
 - Legyen alakzatfókusz is és ürespozíciófókusz is. A kettő kizárja egymást: ha alakzatra kattintok, alakzatfókusz és az az alakzat fókuszba kerül. Ha üres helyre kattintok, a fókuszalakzat elveszti fókuszát, és üreshelypozíciófókusz képződik. Előbbi törlésre, utóbbi beszúrásra reagál. Az ürespozíció (WEPOs)-fókusz esetleg meg is jeleníthető (kis pötty, kis kereszt?) bár nem szükségszerű.
 - Az Insert és a Delete nem mód, hanem funkció. Két mód elég: a jelenelg Obsolete-nek nevezett Kompakt mód, és a Normál mód. A Normál mód legyen az alapértelmezés.
 - Kurzornyilakkal is lehessen mozgatni (tologatni) az alakzatokat. Alternatív megoldás: csúszkákkal. A csúszkák forgatáshoz, és tükrözéshez is használhatók
 - Az ürespozíció-fókusznak és az alakzatfókusznak nem kell felétlenül egymást kizáróank lennie. Lehet az is, hogy háromféle fókusz lehet a bufferben: alakzatfókusz, pozíciófókusz és orientációfókusz. Az alakzat- és a pozíciófókusz szerepe az lenne, ami eddig, plusz még a pozíciófókusz felhasználható lenne még forgatás középpontjának megadsára is. Az orientációfókusz meg tükrözés tengelyét adná meg (a pozíciófókusszal együtt)

 - Az alakzatoknak referenciapontjuk mellett referenciaszögök is legyen. Ez lehet automatikus: a konstruktor megadhat default 0 referenciaszöget. A lényeg, hogy a forgatás kövesse. Átgondolandó askálázások hatása, de szerintem nem hatnak rá. Épp fordítva: a scaleX és scaleY a referenciaszög szerint számít mostantól, nem az abszolút vízszintes szerint.
 - Legyenek buktatások: az alakzat legyen képes rábukni a taplpára, illetve a következő/előző oldalára vízszntesbe.

 - Az Állapotgépet lehetne több részre vágni. Egyelőre megtartanánk az egységes közös Állpotot (State). A State osztálynak sajt metódusai nem lennének (csak getterek és szetterek), vagy még azok sem, szóval csak példányváltozói lennének. A közöst State-t sok Machine használná(var machine1 = new Machine1(state). Több osztály is lenne a Machine-k között. Az  egyes Machine osztályok a bemeenet és a kimenet alapján különölnének el. Bemeneten értjük a transition függvény szignatúrájának a bemeneti dolgokra vonatkozó részét, kimeneten meg azt, hogy a Machine milyen akciókat, tevőleges dolgokat hajt végre (rajzolások pl.), vagyis hogy milyen modulokat kell importálnia, használnia, hogy feladatát végezhesse. A ,,közös'' State kiemelésével a Statemachine-ből, és a ,,megmaradt'' Statemachine szétvgágása külön StateMachine-kre: így a felhasználó felület még tisztábban elválik a matematikai motortól, így még könnyebb lesz tetszőlegesen testre szabni a kívánt felhasználóbarát kezelőfelületet. A mostani betűparancsok elvileg továbbélhetnek majd olyan formában, hogy egy felhasználó által programozható szöveges szkriptnyelv részeivé válhatnak. Persze ez a jelen feladat szempontjából nem fontos, ezt csak a TODO listába írom be.
 - Legyen belső API, esetleg majd REST API is. ,,API frst'' szemlélet?

 - Legyen magasz ,szintű, ütközés típusú eemény! Ahogy az seseményfeldobó programrész képes már geometriai (és nem SVG-koordinátás) szintű információkat feldobni, ugyanúgy legyen ezen a téren is egy kis fogalmi emelés: ne csak natív eseményeket dobjon fel! Az e event objektum helyett legyen valami Either Event MyHighlevelEvent! Ez még ne akarja az ütközést tényelges lekezelni, hanem infókat tartalmazzon, amit aztán bármilyen ütközésszabályzat szerint fel lehessen dolgozni. Amúgy ez a saját magaszintű ütközésesemény elvégezhet ütözésinterpolációs számításokat is, az nincs megtiltva, használhat és mozgathat virtuális próbafigurát. Az van csak megtiltva, hogy a tényleges figurán ö maga akciót hajtson végre, az eredeti figurát tevőleges visszarántsa valami kiszámolt pozícióba. Ezt ne tegye, csak infókat adjon!

 - Teszteleni normál módnál és kompakt módnál is: ha a `sampleBank` által beszúrt egyik alakzatot elcsavarom, aztán elkezdek stamp-elni úgy, hogy épp azt az alakzatot választom ki pecsétnek, akkor a torzított  pecsétet teszi ki, vagy az eredetit?
    - általában is ellenőrozni kell, hogy pecsételéskor, mág általánosabban létrehozáskor történik-e klónozás ott, ahol kell, és klónozásmentes-e ott, ahol fölösleges lenne klónozni.
 - Az ütközésnél a rugalmas fogómegcsúszás visszahajlása is, és az átbuktatás is végre rendben működik, de objktumot egy másik objektum éle mentén csusztatni, reszelni nem lehet. Ezt is valósítsuk meg!

 - A körüljárásdetektálási hiba javítása (amikor sem +360 fok sem -360 fok nem jön ki a külső szögek összegére - átnyúló konkáv szögeknél jelenik meg ilyesmi).

 - `flat` and `flatMap` are experimental, do not use them, define them expilcitly!
 - Define a  `mbMinBy2WayCmp` and `minsBy3WayCmp` function, and redefine `nearestFiguresHence` and `nearestVerticesHence` and `maybeNearestFigureHence` and `maybeNearestVerticeHence` (and possibly others as well) by them (lift out the common pattern).
 - put to a separate class? Figure is already a too large class. `addVertex`, `deleteVertex`, `moveVertex` by proximity heurietics should come directly into `Figure`, or should we use a spearate `FigureEditor` class?
 - Amikor az alakzatszerkesztővel nagyon hegyes, sziklaszerű kitüremkedésű alakzatot állítok elő, néha az ilyen sziklaszerű kitüremkedés áthatolható marad az ütközésérzékelés számára. Ez persze hiba. lehet, hogy a háttérben átmetsző vonalmetszésű, invalid poligon áll, amelyen ez nem látszik szemre.
 - `injectorMain`, `Router`, `FigureEditorController`, `GeomTransformationController`: dönteni kell abban, hogy e kontrollerek a `NormalModeController`-rel és a `CompactModeConroller`-rel közös nagy `State` állapotosztályt használják-e, vagy saját állapotterük legyen, akár úgy, hogy közvetlen az adott kontroller attributumaként, akár minden egyes kotrollerhez külön-külön egy-egy a kotrollerhez tartozó State* osztályként.
     - Valószínűleg inkább mégis érdemes megtartani a `NormalModeController`-rel és a `CompactModeConroller`-rel közös nagy `State` állapotosztályt a `FigureEditorController` és a `GeomTransformationController` számára is. Ugyanis egyáltalán nem biztos, hogy ezeknél továbbra is a ,,legközelebbi alakzat heurusztukéjéra'' fogunk támaszkodni. A legközelebbi pont és él (adott lakazaton belül) heurisztikája megmaradhat, de magát a szekesztendő vagy transzformálandó alakzatot a fókusz fogja megadni, nem közelségi heurisztika. Ebben tehát az a `FigureEditorController` és a `GeomTransformationController` használni fogja az alakzatfókuszt, sőt, lehet, hogy maguk e kontrollerek maguk is beleolvadnak a `NormalModeController`-be. Ennek fő oka, hogy előfordulhat, hogy oly alakzat csúcsát akarom elmozgatni, amely alakzat épp abban a csúcsban közös csúcsot alkot egy másik alakzat ccsúcsával. Ekkor a két csúcsa közelségi heurisztika számára megkülönböztethetetlen, de az alakzatfókusz tökéletes megoldást adna. Ezért a `FigureEditorController`-nak mindenképp át kéne venni a fókusz használatát. A `GeomTransformationController` esetleg használhatná a közleségi heurisztikát, de talán az is jobb ha fókuszalapú.
 - Megcsináltam az egérrel való vonszolós, interaktív forgatást, és hamarosan kész lesz a többi transzformáció itisztán egeres-interaktív változata is. Egyylre még nem végez ütközésvizsgálatot, tehát egy alakzatot bele lehet forgatni egy másik alakzattal érvénytelen helyzetbe is. Ennek során kiderült, hogy a program ilyenkor hibaüzenett ad, tehát nem talál rá valamiféle erre előkészített kivételere. Bár nyilván hamar meg lesz írva a transzformációk ütközésvizsgálata, de a probléma túlmutat ezen. Alacsony szinten is legyen jól lekezelve az érvénytelen helyzet. A hibaüzenet:
        Uncaught TypeError: pMInf1 is not iterable
            at pMInfCompare (Infinity.js:64)
            at reducer (Infinity.js:164)
            at boardReduce (Board.js:5)
            at boardMinSelectSet (Infinity.js:175)
            at fallFigureOnBoard_allMins (FiguresBoard.js:5)
            at mbVectorTransformer (collision-as-vector-transformation.js:5)
            at infinitezimalDisplacement (collision-as-vector-transformation.js:1)
            at NormalModeController.mouseMove (NormalModeController.js:33)
            at Router.dispatch (Router.js:28)
            at mergelessSubscribe (WidgetEventPillar.js:18)

 - Az ütközés invalidus helyzetei más érdekeségre is rávilágítanak. Van két nagyon pici négyzet, az egyik pont a nagyon konkávalakzatnál. Ez érzékeltlen az ütközésre beforgatáskor. Miért? Akr direkt volt így, akr nemszándékolt melékhatása valaminek, érdemes lenne utánanézni. Ez az átjárhatóság ugyanis pont jól jönne nyilászáróknál.
 - Az Alakzatszerkesztő (Figure Editor) rendelkezzék területtartási kapcsolóval, opcióval is!
 - Amikor az alaprajzot natív  formátumban mentjük, tervezzük meg ezt a natív formátumot minél nyitttabra! Lehessen az alkalmazás nélkül is, sima szövegszerkesztőben is alaprajzokat szerekszteni! Lehetőleg legyen olyan ebben a nyitottsgban, mint a LaTeX!
 - Ha már natív mentés: legyen Redo (az alakalmazásban), a metést pedig kísérje valamiféle saját verziókövetés!
 . az  `ird.currentWEPos` érzékelését törzítja, ha pl. egérvonszolás közben megváltozik az oldal layoutja (pl. mert a debuggoló konzolüzenet hol két sorba, hol egy sorba fér ki). Ez valószínűleg lacsonyszintű jelenség, és a `.svgPoint.matrixTransform(this.svgRootElement.getScreenCTM().inverse())` szintjéig nyúlik vissza.
 - Tudjuk, hogy már lehet egérrel pontot hozzáadni, törölni, vonszolni. Továbbá lehet egérrel alakzatot forgatni. Mindezt kényelmesen intuitívan, tehát vonszolással,
Az ütközésvizsgálat közben értelemszerűen működik (vagyis nem lehet alakzatot tilos helyzetbe beforgatni). Ugyanakkor, ez az ütközésvizsgálat az alakzatszerkesztés (csúcspontok hozzáadása, mozgatása) esetében nem működik! Pl. csúcsot mozgatva bele lehet trappolni egy másik alakzaba.
 - Ettől függetlenül is, a közelségi heurisztika kissé katasztrofális az alakzatszerkesztőben. Nem a csúcsok, élek közelségi megsejtésével van a baj, hanem a legközelebbi alakzat közelséi heurisztikájával. Nagyon csúnyá össze lehet kuszálni az  alakzatszekesztés vele (pl. egy mozgatott csúcs esetén, ha túl közel megyünk vele egy szomszéd alakzathoz, akkor a szekesztés váratlanul átugrik a szomszéd alakzatra).
 - És ettől is függetlenül, baj, hogy az alakzatszekesztő megengedni, hogy kereszteződő élű, kifordult alakzatok jöjjenek létre.
